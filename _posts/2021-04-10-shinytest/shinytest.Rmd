---
title: "Shiny_test"
description: |
  A short description of the post.
author:
  - name: Kevin Gunawan Albindo
    url: https://www.linkedin.com/in/kgalbindo
date: 04-10-2021
runtime: shiny
output: html_document
draft: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Installing and loading necessary packages

```{r echo=TRUE, results='hide'}
packages = c('tidyverse', 'tidymodels', 'ggplot2', 'ggfittext', 'plotly', 'skimr',
             'kableExtra', 'vip', 'ggstatsplot', 'corrplot', 'ggcorrplot',
             'Boruta', 'vip', 'Hmisc', 'shinyWidgets', 'reshape2', 'tidytext')

for(p in packages){
  if(!require(p, character.only = T)){
    install.packages(p)
  }
  library(p, character.only = T)
}
```

### Load cleaned data
The cleaned data is loaded using read_csv function from readr package.
```{r echo=TRUE}
listing_prep <- read_csv("data/listing_08042021.csv")

preset_vars <- c("host_response_time", "host_response_rate" , "host_acceptance_rate",
             "host_is_superhost", "host_listings_count", "host_identity_verified",
             "neighbourhood_cleansed", "neighbourhood_group_cleansed", "latitude",
             "longitude", "property_type", "room_type", "accommodates", "bedrooms",
             "beds", "minimum_nights", "maximum_nights", "availability_30",
             "availability_60", "availability_90", "availability_365",
             "number_of_reviews", "review_scores_rating", "instant_bookable",
             "reviews_per_month", "name_length", "description_length",
             "host_about_length", "bathroom", "bathroom_type",
             "host_verifications_count", "amenities_count", "days_joined", "price")

listing_prep <- listing_prep %>%
  mutate(across(where(is.character), as.factor)) %>%
  mutate(across(where(is.logical), as.factor)) %>%
  select(all_of(preset_vars))
```

### Get user input on response variable
In this data set, there are 2 choices of response variable: _price_ and _review_scores_rating_.

```{r echo=FALSE}
var_list <- sort(names(listing_prep))

var_list_num <- listing_prep %>%
    keep(is.numeric) %>%
    names()

pickerInput(
   inputId = "Itarget_var",
   label = "Choose response variable:",
   choices = c("price", "review_scores_rating"),
   selected = "price")
 
```

### Correlation matrix for numeric variables
Next, we want to check correlation among numeric variables. User can further choose which numeric variables to be considered. Subsequently, choice of correlation type and p-value are available to customise the correlation matrix.

```{r echo=FALSE}
multiInput(
  inputId = "Inum_vars_corr",
  label = "Choose from numeric variables :",
  choices = var_list_num,
  width = "900px")

actionButton("btn_all_num", "Select all")
actionButton("btn_des_all_num", "Deselect all")

radioButtons(
   inputId = "Icorr_type",
   label = "Correlation type:",
   choices = c("Pearson", "Kendall", "Spearman"))

pickerInput(
   inputId = "Isig_lvl_corr",
   label = "p-value:",
   choices = c("0.01", "0.05", "0.1"),
   selected = "0.05")

actionButton("btn_corrplot", "Plot correlation matrix")

plotlyOutput("Oplot_corrmat", width = "800px", height = "600px")
```

```{r echo=FALSE}
observeEvent(input$btn_corrplot, {
  listing_prep2_num <- listing_prep %>%
      select(input$Inum_vars_corr)
    
  corM <- cor(listing_prep2_num,
          use = "pairwise.complete.obs",
          method = tolower(input$Icorr_type))
  
  p_mat <- cor_pmat(listing_prep2_num)
  
  corM[upper.tri(corM)] <- NA
  p_mat[upper.tri(p_mat)] <- NA
  
  mlt_cor <- melt(corM, value.name = "Correlation")
  mlt_p <- melt(p_mat, value.name = "pValue")
  mlt_df <- merge(mlt_cor, mlt_p)
  
  mlt_df_x <- mlt_df %>%
    na.omit() %>%
    filter(pValue > input$Isig_lvl_corr)
    
  gheat <- ggplot(NULL, aes(Var1, Var2, fill = Correlation,
                           text = paste0(Var1," - ", Var2, "\n",
                                        "Correlation: ", round(Correlation, 3),
                                        "\nP-val: ", round(pValue, 3)))) +
    geom_tile(data = mlt_df) + 
    scale_fill_gradient2(low = "blue", high = "red", mid = "white",
                         midpoint = 0, limit = c(-1,1),
                         name=paste0(input$Icorr_type,"\nCorrelation"))
  
  len_var <- length(input$Inum_vars_corr)
  if (len_var <= 20){
      gheat <- gheat +
        geom_text(data = mlt_df, aes(Var1, Var2,
                               label = round(Correlation, 1)), size = 3)
  }

  gx <- gheat + 
    geom_point(data = mlt_df_x, shape=4, size=1.5,
               stroke=0.1, fill=NA, color="black") +
    scale_shape_identity() +
    theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1, size = 7),
        axis.text.y = element_text(size = 7),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.grid.major = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank(),
        axis.ticks = element_blank(),
        legend.title = element_text(size = 7),
        legend.text = element_text(size = 6))

  output$Oplot_corrmat <- renderPlotly({
    ggplotly(gx, tooltip=c('text'))
  })
})

observeEvent(input$btn_all_num, {
  updateMultiInput(
    session = session,
    inputId = "Inum_vars_corr",
    selected = var_list_num)
})

observeEvent(input$btn_des_all_num, {
  updateMultiInput(
    session = session,
    inputId = "Inum_vars_corr",
    selected = character(0))
})
```

### Remove highly correlated variables

```{r echo=FALSE}
multiInput(
  inputId = "Iremove_var",
  label = "Choose variables to be removed:",
  choices = var_list,
  width = "900px")

actionButton("btn_remove_var", "Remove variable")

Rlisting_prep <- reactiveValues(data = listing_prep)

observeEvent(input$btn_remove_var, {
  Rlisting_prep$data  <- listing_prep %>%
    select(-all_of(input$Iremove_var))
})
```


### Train/test data split
The next step will be to split the data into train and test set. User will be able to choose the proportion and strata requirement.

```{r echo=FALSE}
sliderInput("Itrain_prop", "Training set proportion (%)", value = 80, min = 50, max = 100, step = 5)

awesomeCheckbox(
   inputId = "Itrain_strata",
   label = "Stratified sampling for target variable",
   value = TRUE)

actionButton("btn_split_data", "Split data set")

# pickerInput(
#    inputId = "Iplot_num_tt",
#    label = "Numeric variables:",
#    choices = var_list_num)

plotlyOutput("Oplot_traintest_dense", width = "800px", height = "1100px")
plotlyOutput("Oplot_traintest_bar", width = "800px", height = "900px")

Rdatasplit <- reactiveValues(data = NULL, train = NULL, test = NULL)

observeEvent(input$btn_split_data, {
  set.seed(1234)
  Rdatasplit$data <- Rlisting_prep$data %>%
    drop_na(input$Itarget_var) %>% #remove rows where target variable is missing
    mutate(id = row_number()) %>%
    initial_split(prop = isolate(input$Itrain_prop)/100,
                  strata = isolate(input$Itarget_var))
  
  Rdatasplit$train <- training(Rdatasplit$data)
  Rdatasplit$test <- testing(Rdatasplit$data)

  train_num <- Rdatasplit$train %>%
    mutate(split = "training")
  test_num <- Rdatasplit$test %>%
    mutate(split = "test")
  trainTest_num <- rbind(train_num, test_num)

  # output$Oplot_traintest_dense <- renderPlotly({
  #   g1 <- trainTest_num %>%
  #     select(input$Iplot_num_tt | split) %>%
  #     gather(key, value, -split) %>%
  #     ggplot(aes(x = value, fill = split)) +
  #       geom_density(alpha=0.5)
  #   ggplotly(g1)
  # })
  
  output$Oplot_traintest_dense <- renderPlotly({
    g1 <- trainTest_num %>%
      select(where(is.numeric) | split) %>%
      select(-id) %>%
      gather(key, value, -split) %>%
      ggplot(aes(x = value, fill = split)) +
      facet_wrap(~ key, scales = "free", ncol = 4) +
      geom_density(alpha=0.5)
    ggplotly(g1)
  })
  
  output$Oplot_traintest_bar <- renderPlotly({
    g2 <- trainTest_num %>%
      select(where(negate(is.numeric)) | split) %>%
      gather(key, value, -split) %>%
      filter(!is.na(value)) %>%
      ggplot(aes(x = value, fill = split)) +
      geom_bar() +
      facet_wrap(~ key, scales = "free", ncol = 3) +
      # theme(axis.text.x = element_text(angle = 45))
      theme(axis.text.x = element_blank())
    ggplotly(g2)
  })
})
```

### Feature importance
We will use 2 methods of feature importance analysis:  
1. Using ranger package, we can fit the response variable and predictors to a random forest model and calculate its importance  
2. Using boruta algorithm as an improvement from the original random forest model

```{r echo=FALSE}
# fit variables to random forest model

actionButton("btn_get_ftimp", "Calculate feature importance")
# plotlyOutput("Oplot_ftimp_rf", width = "800px", height = "500px")
# plotlyOutput("Oplot_ftimp_b", width = "800px", height = "500px")

fixedRow(
  column(6, plotlyOutput("Oplot_ftimp_rf")),
  column(6, plotlyOutput("Oplot_ftimp_b"))
)
  
observeEvent(input$btn_get_ftimp,{
  f <- as.formula(paste(input$Itarget_var, "~ ."))

  rf_res1 <- ranger::ranger(f, data = Rdatasplit$train %>%
                                      na.omit() %>%
                                      select(-id),
                          importance = "permutation")

  rf_p <- ranger::importance(rf_res1) %>%
    enframe("Variable", "Importance") %>%
    mutate(Variable = fct_reorder(Variable, Importance)) %>%
    arrange(desc(Importance)) %>%
    ggplot(aes(x = Variable, y = Importance,
               text = paste0(Variable, "\nImportance:", round(Importance,3)))) +
    geom_col() +
    coord_flip() +
    scale_fill_viridis_d(end = .7) +
    labs(title = "Feature Importance (RF)") +
    theme(plot.title = element_text(size = 10),
          axis.title.y = element_blank())

  output$Oplot_ftimp_rf <- renderPlotly(
    ggplotly(rf_p, tooltip = c('text')))
  
  # Feature importance using boruta
  boruta_output <- Boruta(f, data = Rdatasplit$train %>%
                                      na.omit() %>%
                                      select(-id),
                          maxRuns = 50,
                          doTrace = 0)
  # boruta_signif <- names(boruta_output$finalDecision[boruta_output$finalDecision %in% c("Confirmed", "Tentative")])  # collect Confirmed and Tentative variables
  # print(boruta_signif)
  
  boruta_output_tbl <- as.data.frame(boruta_output$ImpHistory) %>%
    gather()
  
  fac <- with(boruta_output_tbl, reorder(key, value, median, order = TRUE))
  boruta_output_tbl$key <- factor(boruta_output_tbl$key, levels = levels(fac))
  
  boruta_p <- boruta_output_tbl %>%
    filter(!str_detect(key, 'shadow')) %>%
    ggplot(aes(x = key, y = value)) +
    geom_boxplot() +
    coord_flip() +
    labs(title = "Feature Importance (Boruta)") +
    ylab("Importance") +
    theme(plot.title = element_text(size = 10),
          axis.title.y = element_blank())
  ggplotly(boruta_p)
  
  output$Oplot_ftimp_b <- renderPlotly(
    ggplotly(boruta_p))
  
})
```

### Build transformation recipe
A predefined transformation process for the variables are provided for information. Transformed variable will be plotted side by side with their pre-transformed values for comparison.

```{r echo=FALSE}
actionButton("btn_rcpTransform", "Prepare recipe")
verbatimTextOutput("Otransform_recipe")

pickerInput(
  inputId = "Iproc_var",
  label = "Check transformed variables:",
  choices = NULL)
plotlyOutput("Otransformed_plot")

RtrainTProcessed <- reactiveVal(NULL)

observeEvent(input$btn_rcpTransform,{
  f <- as.formula(paste(input$Itarget_var, "~ ."))
  
  rcpTransform <- recipe(f, data = Rdatasplit$train) %>%
    update_role(id, new_role = "id variable") %>%
    step_naomit(all_predictors(), skip = TRUE) %>% #remove rows with NA
    step_corr(all_numeric(), -all_outcomes(), threshold = 0.7,
              method = "pearson") %>% #remove correlated variables at 0.7 threshold
    step_normalize(all_numeric(), -all_outcomes()) %>%
    step_other(all_predictors(), -all_numeric(),
               threshold = 0.05, other = "Others") %>%
    step_dummy(all_nominal(), -all_outcomes())

  output$Otransform_recipe <- renderPrint(rcpTransform)
  
  #see the transformed data
  listingTrain_T <- rcpTransform %>% prep() %>% juice()

  listingTrain_T %>%
    gather() %>%
    ggplot(aes(x = value)) +
      facet_wrap(~ key, scales = "free", ncol = 4) +
      geom_bar()

  listing_train_var <- Rdatasplit$train %>%
    keep(is.numeric) %>%
    names()

  listingTrain_T_var <- listingTrain_T %>%
    keep(is.numeric) %>%
    names()

  intersect_vars <- intersect(listing_train_var, listingTrain_T_var)
  intersect_vars <- intersect_vars[intersect_vars != "id"]

updatePickerInput(
  session = session,
  inputId = "Iproc_var",
  choices = intersect_vars)

train_proc <- Rdatasplit$train %>%
  select(all_of(intersect_vars)) %>%
  mutate(processed = "original")

train_T_proc <- listingTrain_T %>%
  select(all_of(intersect_vars)) %>%
  mutate(processed = "processed")

RtrainTProcessed(rbind(train_proc, train_T_proc))
})

output$Otransformed_plot <- renderPlotly(
  ggplotly(
    RtrainTProcessed() %>%
      select(input$Iproc_var | processed) %>%
      gather(key, value, -processed) %>%
      ggplot(aes(x = value)) +
      geom_histogram(alpha=0.5)) +
      facet_wrap(~ processed, scales = "free_x")
  )
```





